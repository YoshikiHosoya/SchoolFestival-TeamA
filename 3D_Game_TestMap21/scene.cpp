// =====================================================================================================================================================================
//
// シーンの処理 [scene.cpp]
// Author : Sato Yoshiki
//
// =====================================================================================================================================================================
#include "scene.h"			// インクルードファイル
#include "renderer.h"

// =====================================================================================================================================================================
// 静的メンバ変数の初期化
// =====================================================================================================================================================================
int			CScene::m_nNumAll = 0;
bool		CScene::m_bStop = false;
CScene		*CScene::m_apTop[CScene::PRIORITY_MAX] = {};
CScene		*CScene::m_apCur[CScene::PRIORITY_MAX] = {};

// =====================================================================================================================================================================
// マクロ定義
// =====================================================================================================================================================================

// =====================================================================================================================================================================
//
// コンストラクタ
//
// =====================================================================================================================================================================
CScene::CScene()
{
}

// =====================================================================================================================================================================
//
// コンストラクタ
//
// =====================================================================================================================================================================
CScene::CScene(PRIORITY Priority)
{
	// 死亡フラグの初期化
	m_bDeath	= false;

	// 止めるフラグの初期化
	m_bStop		= false;
	
	// 両方NULLのとき
	if (m_apTop[Priority] == NULL && m_apCur[Priority] == NULL)
	{
		m_apTop[Priority] = this;				// m_apTopに自身のオブジェクトポインタを代入
		m_apCur[Priority] = this;				// m_apCurに自身のオブジェクトポインタを代入
		m_apPrev = NULL;						// m_apPrevをNULLに
		m_apNext = NULL;						// m_apNextをNULLに
	}
	else
	{
		m_apCur[Priority]->m_apNext = this;		// m_apCurのm_apNextに自身のオブジェクトポインタを代入
		this->m_apPrev = m_apCur[Priority];		// 自身のオブジェクトポインタのm_apPrevにm_apCurを代入
		m_apCur[Priority] = this;				// m_apCurに自身のオブジェクトポインタを代入
	}
	// タイプ保存
	m_priority = Priority;
}

// =====================================================================================================================================================================
//
// デストラクタ
//
// =====================================================================================================================================================================
CScene::~CScene()
{

}

// =====================================================================================================================================================================
//
// オブジェクト全ての解放
//
// =====================================================================================================================================================================
void CScene::ReleaseAll(void)
{
	for (int nCntOrder = 0; nCntOrder < CScene::PRIORITY_MAX; nCntOrder++)
	{
		// m_apTopがNULLじゃないとき
		if (m_apTop[nCntOrder] != NULL)
		{
			CScene *pScene = m_apTop[nCntOrder];	// 空のポインタにm_apTopを代入

			// 空のポインタ(m_apTop)のm_apNextがNULLになるまで
			while (pScene)
			{
				// 次のポインタを控える
				CScene *pSceneNext = pScene->m_apNext;
				// 解放
				pScene->Release();
				// 次のポインタへ
				pScene = pSceneNext;
			}
		}
	}

	for (int nCntOrder = 0; nCntOrder < CScene::PRIORITY_MAX; nCntOrder++)
	{
		// m_apTopがNULLじゃないとき
		if (m_apTop[nCntOrder] != NULL)
		{
			CScene *pScene = m_apTop[nCntOrder];	// 空のポインタにm_apTopを代入

			// 空のポインタ(m_apTop)のm_apNextがNULLになるまで
			while (pScene)
			{
				// 次のポインタを控える
				CScene *pSceneNext = pScene->m_apNext;

				// 死亡フラグが立ったとき
				if (pScene->m_bDeath == true)
				{
					// 解放
					pScene->Death();
					pScene = NULL;
				}
				// 次のポインタへ
				pScene = pSceneNext;
			}
		}
	}
}

// =====================================================================================================================================================================
//
// オブジェクト全ての更新
//
// =====================================================================================================================================================================
void CScene::UpdateAll(void)
{
	// ポーズがかかっていないとき
	if (!m_bStop)
	{
		for (int nCntOrder = 0; nCntOrder < CScene::PRIORITY_MAX; nCntOrder++)
		{
			// m_apTopがNULLじゃないとき
			if (m_apTop[nCntOrder] != NULL)
			{
				CScene *pScene = m_apTop[nCntOrder];	// 空のポインタにm_apTopを代入

				// 空のポインタ(m_apTop)のm_apNextがNULLになるまで
				while (pScene)
				{
					// 次のポインタを控える
					CScene *pSceneNext = pScene->m_apNext;
					// 更新
					pScene->Update();
					// 次のポインタへ
					pScene = pSceneNext;
				}
			}
		}

		for (int nCntOrder = 0; nCntOrder < CScene::PRIORITY_MAX; nCntOrder++)
		{
			// m_apTopがNULLじゃないとき
			if (m_apTop[nCntOrder] != NULL)
			{
				CScene *pScene = m_apTop[nCntOrder];	// 空のポインタにm_apTopを代入

				// 空のポインタ(m_apTop)のm_apNextがNULLになるまで
				while (pScene)
				{
					// 次のポインタを控える
					CScene *pSceneNext = pScene->m_apNext;

					// 死亡フラグが立ったとき
					if (pScene->m_bDeath == true)
					{
						// 解放
						pScene->Death();
						pScene = NULL;
					}
					// 次のポインタへ
					pScene = pSceneNext;
				}
			}
		}
	}
}

// =====================================================================================================================================================================
//
// オブジェクト全ての描画
//
// =====================================================================================================================================================================
void CScene::DrawAll(void)
{
	for (int nCntOrder = 0; nCntOrder < CScene::PRIORITY_MAX; nCntOrder++)
	{
		// m_apTopがNULLじゃないとき
		if (m_apTop[nCntOrder] != NULL)
		{
			CScene *pScene = m_apTop[nCntOrder];	// 空のポインタにm_apTopを代入

			// 空のポインタ(m_apTop)のm_apNextがNULLになるまで
			while (pScene)
			{
				// 次のポインタを控える
				CScene *pSceneNext = pScene->m_apNext;
				// 描画
				pScene->Draw();
				// 次のポインタへ
				pScene = pSceneNext;
			}
		}
	}
}

// =====================================================================================================================================================================
//
// オブジェクトの解放
//
// =====================================================================================================================================================================
void CScene::Release(void)
{
	// 死亡フラグを立てる
	m_bDeath = true;
}

// =====================================================================================================================================================================
//
// ポーズで止める設定
//
// =====================================================================================================================================================================
void CScene::SetPauseStop(bool stop)
{
	m_bStop = stop;
}

// =====================================================================================================================================================================
//
// 死亡フラグ後に解放
//
// =====================================================================================================================================================================
void CScene::Death(void)
{
	CScene * pScene = this;
	if (m_bDeath == true)
	{
		// m_apTopとm_apCurがthisのとき
		if (m_apTop[m_priority] == this && m_apCur[m_priority] == this)
		{
			m_apTop[m_priority] = NULL;		// m_apTopをNULLに
			m_apCur[m_priority] = NULL;		// m_apCurをNULLに
		}
		// m_apTopがthisのとき
		else if (m_apTop[m_priority] == this)
		{
			m_apTop[m_priority] = m_apTop[m_priority]->m_apNext;		// m_apTopのm_apNextをm_apTopに変える
			m_apTop[m_priority]->m_apPrev = NULL;
		}
		// m_apCurがthisのとき
		else if (m_apCur[m_priority] == this)
		{
			m_apCur[m_priority] = m_apCur[m_priority]->m_apPrev;		// m_apCurのm_apPrevをm_apCurに変える
			m_apCur[m_priority]->m_apNext = NULL;
		}
		else
		{
			this->m_apPrev->m_apNext = this->m_apNext;	// thisのm_apPrevのm_apNextが指すポインタをthisのm_apNextに変える
			this->m_apNext->m_apPrev = this->m_apPrev;	// thisのm_apNextのm_apPrevが指すポインタをthisのm_apPrevに変える
		}
	}
	// 終了処理
	pScene->Uninit();

	// メモリの開放
	delete pScene;
}