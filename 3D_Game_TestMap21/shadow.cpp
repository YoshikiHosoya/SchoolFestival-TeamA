// =====================================================================================================================================================================
//
// 影の処理 [shadow.cpp]
// Author : Sato Yoshiki
//
// =====================================================================================================================================================================
#include "shadow.h"			// インクルードファイル
#include "manager.h"
#include "renderer.h"
#include "game.h"
#include "debugproc.h"
#include "camera.h"
#include "player.h"
#include "map.h"

// =====================================================================================================================================================================
// 静的メンバ変数の初期化
// =====================================================================================================================================================================
LPDIRECT3DTEXTURE9	CShadow::m_apTexture	= {};				// テクスチャ情報
int					CShadow::m_nCntNotHit	= 0;				// 当たっていないカウント

// =====================================================================================================================================================================
// マクロ定義
// =====================================================================================================================================================================
#define TEXTURE_FILE01			"data/TEXTURE/shadow.jpg"		// 読み込むテクスチャファイル名			( 影 )

#define SHADOW_SIZEX			(45 / 2)						// 床の幅
#define SHADOW_SIZEY			(45 / 2)						// 床の高さ

#define GRAVITY_VALUE			(50.0f)							// 重力の値
#define SHADOW_SIZE_Y			(50.0f)							// 影のサイズY
#define SHADOW_SIZE_XY			(4.0f)							// 影のサイズXY
#define	NOT_HIT_TIME			(25 * 1)						// 影があったっていない時間

// =====================================================================================================================================================================
//
// コンストラクタ
//
// =====================================================================================================================================================================
CShadow::CShadow() :CScene3D(PRIORITY_EFFECT)
{
}

// =====================================================================================================================================================================
//
// デストラクタ
//
// =====================================================================================================================================================================
CShadow::~CShadow()
{
}

// =====================================================================================================================================================================
//
// 初期化処理
//
// =====================================================================================================================================================================
void CShadow::Init()
{
	// 変数初期化
	m_posOld		= D3DXVECTOR3(0.0f, 0.0f, 0.0f);		// 過去の位置
	m_move			= D3DXVECTOR3(0.0f, 0.0f, 0.0f);		// 移動
	m_size			= D3DXVECTOR3(0.0f, 0.0f, 0.0f);		// サイズ
	m_col			= D3DXCOLOR(1.0f, 1.0f, 1.0f, 0.3f);	// 色
	m_nCntNotHit	 = 0;									// 当たっていないカウント

	// 初期化
	CScene3D::Init();
	//色の設定
	CScene3D::SetColor(m_col);
}

// =====================================================================================================================================================================
//
// 終了処理
//
// =====================================================================================================================================================================
void CShadow::Uninit(void)
{
	CScene3D::Uninit();
}

// =====================================================================================================================================================================
//
// 更新処理
//
// =====================================================================================================================================================================
void CShadow::Update(void)
{
	// プレイヤーの情報取得
	CPlayer *pPlayer = CManager::GetGame()->GetPlayer();
	// 位置取得
	D3DXVECTOR3 pos = CScene3D::GetPos();
	// 当たり判定用のサイズ
	D3DXVECTOR3 HitSize = D3DXVECTOR3(SHADOW_SIZE_XY, SHADOW_SIZE_Y, SHADOW_SIZE_XY);

	// カウントアップ
	m_nCntNotHit++;

	// プレイヤーの位置に合わせる
	pos.x = pPlayer->GetOldPos().x;
	pos.z = pPlayer->GetOldPos().z;

	// 過去の位置保存
	m_posOld = pos;
	
	// 重力
	m_move.y -= GRAVITY_VALUE;

	// 位置更新
	pos += m_move;

	// オブジェクトの当たり判定
	if (CMap::CollisionObjectAll(&pos, &m_posOld, &m_move, &HitSize))
	{
		// カウント初期化
		m_nCntNotHit = 0;
	}
	// 2Dオブジェクトの当たり判定
	else if (CMap::CollisionObject2DAll(&pos, &m_posOld, &m_move, &HitSize))
	{
		// カウント初期化
		m_nCntNotHit = 0;
	}

	// 一定時間たったら
	if (m_nCntNotHit >= NOT_HIT_TIME)
	{
		// 影の位置をプレイヤーに合わせる
		pos.y = pPlayer->GetPos().y;

		// カウント初期化
		m_nCntNotHit = 0;

		// 重力を0に
		m_move.y = 0;
	}

	if (pPlayer->GetLandFlag())
	{
		// 影の位置をプレイヤーに合わせる
		pos.y = pPlayer->GetPos().y;

		// 重力を0に
		m_move.y = 0;
	}

	// 位置の設定
	CScene3D::SetPos(pos);

	// 更新
	CScene3D::Update();

	// テクスチャの分割設定
	CScene3D::SetTexSeparate(1);

	CDebugProc::Print("ShadowPos (%.1f, %.1f, %.1f)\n\n", pos.x, pos.y, pos.z);

}

// =====================================================================================================================================================================
//
// 描画処理
//
// =====================================================================================================================================================================
void CShadow::Draw(void)
{
	LPDIRECT3DDEVICE9 pDevice = *CManager::GetRenderer()->GetDevice();	// デバイスの取得

	pDevice->SetRenderState(D3DRS_ZFUNC, D3DCMP_LESSEQUAL);						// テストをパスする
	pDevice->SetRenderState(D3DRS_ZWRITEENABLE, FALSE);

	// レンダーステート(減算合成処理)
	pDevice->SetRenderState(D3DRS_BLENDOP, D3DBLENDOP_REVSUBTRACT);
	pDevice->SetRenderState(D3DRS_SRCBLEND, D3DBLEND_SRCALPHA);
	pDevice->SetRenderState(D3DRS_DESTBLEND, D3DBLEND_ONE);

	// 描画
	CScene3D::Draw();

	// レンダーステート(通常ブレンド処理)
	pDevice->SetRenderState(D3DRS_BLENDOP, D3DBLENDOP_ADD);
	pDevice->SetRenderState(D3DRS_SRCBLEND, D3DBLEND_SRCALPHA);
	pDevice->SetRenderState(D3DRS_DESTBLEND, D3DBLEND_INVSRCALPHA);

	pDevice->SetRenderState(D3DRS_ZENABLE, D3DZB_TRUE);								// Zテストを有効にする
	pDevice->SetRenderState(D3DRS_ZFUNC, D3DCMP_LESSEQUAL);							// デフォルトに戻す
	pDevice->SetRenderState(D3DRS_ZWRITEENABLE, TRUE);

	// アルファテストを無効にする
	pDevice->SetRenderState(D3DRS_ALPHATESTENABLE, FALSE);
}

// =====================================================================================================================================================================
//
// 壁の生成
//
// =====================================================================================================================================================================
CShadow * CShadow::Create(void)
{
	// 変数
	CShadow *pShdow;

	// メモリの確保
	pShdow = new CShadow;

	// 初期化
	pShdow->Init();

	pShdow->m_size = D3DXVECTOR3(SHADOW_SIZEX, 0.0f, SHADOW_SIZEY);	// サイズ

	// 両面カリングの設定
	pShdow->SetBothSideCulling(false);

	// 回転の設定
	pShdow->SetRot(D3DXVECTOR3(0.0f, 0.0f, 0.0f));

	// サイズの設定
	pShdow->SetSize(pShdow->m_size);

	// テクスチャの割り当て
	pShdow->BindTexture(m_apTexture);
	
	return pShdow;
}

// =====================================================================================================================================================================
//
// ロード
//
// =====================================================================================================================================================================
HRESULT CShadow::Load(void)
{
	// デバイスの取得
	LPDIRECT3DDEVICE9 pDevice = *CManager::GetRenderer()->GetDevice();

	// テクスチャ読み込み
	D3DXCreateTextureFromFile(pDevice, TEXTURE_FILE01, &m_apTexture);

	return S_OK;
}

// =====================================================================================================================================================================
//  
// アンロード
//
// =====================================================================================================================================================================
void CShadow::Unload(void)
{
	// テクスチャの開放
	if (m_apTexture != NULL)
	{
		m_apTexture->Release();
		m_apTexture = NULL;
	}
}